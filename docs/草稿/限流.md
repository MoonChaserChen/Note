# 限流
## 限流算法
### 固定窗口计数器
1. 将时间划分为多个固定时长的窗口
2. 在每个窗口内每有一次请求就将计数器加一，如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃
3. 当时间到达下一个窗口时，计数器重置
可能问题：
1. 固定窗口内访问不均匀导致通过请求量允许为限制的两倍
2. 对固定窗口内流量突增时，后续请求直接拒绝，太过直接粗暴（即不支持超频）
### 滑动窗口计数器
固定窗口计数器方式窗口连续且没有重叠，滑动窗口计数器则是采用窗口按一个小于窗口宽度的步长滑动，同时动态计算窗口内的流量，超过流量则拒绝。
方案特点：
解决了固定窗口请求量为限制的两倍的问题，但也不支持超频
### 漏桶
漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行（类似于漏桶中的水以肯定的速率漏水），过多的请求则放在队列中排队或直接拒绝
可能问题：
短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应
### 令牌桶
1. 令牌以固定速率生成
2. 生成的令牌放入令牌桶中存放，如果令牌桶满了则多余的令牌会直接丢弃
3. 当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行；若桶空了未取到，则限时等待或直接丢弃
特点：
令牌桶算法既能够将所有的请求平均分布到时间区间内，又能接受服务器能够承受范围内的突发请求（桶越大，承受范围越大）
## 限流方案
### 单点限流
guava-RateLimiter 令牌桶限流
### 分布式限流
1. Hystrix、resilience4j、Sentinel等框架
2. 采用redis实现